% This uses my article.tex include.
\input{article.tex}
% We use noweb.
\usepackage{noweb}
\def\cmd{\emph}
\def\func{\emph}
\def\param{\texttt}
\def\str{\texttt}
\def\bs{\textbackslash}
\def\key{\texttt}
\newcommand\ctrl[1]{\key{\char`\^#1}}
% The fun begins.
\begin{document}

\section{Introduction}

\subsection{Background: Computer forensics}

\subsubsection{Documentation of terminal sessions}

\subsection{Tasks}

\subsection{Results}

\subsection{Outlook}

\section{\cmd{script}}
\emph{util-linux} is the name of a collection of command-line utilities for Linux systems.
It includes essential software like \cmd{dmesg}, \cmd{fdisk}, \cmd{mkswap}, \cmd{mount} and \cmd{shutdown} as well as the \cmd{script} and \cmd{scriptreplay} utilities.

The original \emph{util-linux} package was abandoned in 2006.
Today, it has been replaced by its successor \emph{util-linux-ng}, a fork of the last available \emph{util-linux} version.
\emph {util-linux-ng} is under active development.
The analysis of the original \cmd{script} utility in this thesis is based on the most recent \emph{util-linux-ng} release as of the time of writing, version 2.17.

\subsection{Invocation}
\cmd{script} takes one optional argument, the file name of the typescript file to generate.
If the argument is omitted, the file will be named \emph{typescript}.
There are also several command-line switches that modify \cmd{script}’s behavior.

The \param{-a} switch will pass the \emph{a} flag to \func{fopen()}’s \emph{mode} parameter instead of \emph{w}.
If a typescript file does already exist, it will then not be overwritten; instead, the new content will be appended to the existing file.

If the \param{-f} switch is used, \cmd{script} will call \func{fflush()} on the typescript file after new data has been written to it.
This results in instant updates to the typescript file, at the expense of performance.

%FIXME: Continue.

\subsection{File formats}
The current implementation of \cmd{script} uses a very simple typescript file format:
Everything the client application sends to the terminal (i.e. everything printed on screen) will be written to the file, byte by byte, including control characters that are used for various tasks like setting colors, positioning the cursor etc.
Additionally, a header \str{"Script started on XXX\bs{}n"} is written, where \str{XXX} is the human-readable date and time when \cmd{script} was invoked.
If \cmd{script} was invoked without the \param{-q} flag, an additional footer \str{"Script done on YYY\bs{}n"}, where \str{YYY} is the human-readable date and time when \cmd{script} terminated, is written.

Since this typescript format completely lacks timing information, the \param{-t} flag will output timing data to stderr.
The user has to capture this output to a file by calling \cmd{script} like this: \str{script -t 2>timingfile}.

The timing file consists of tuples of delay and byte count (space-separated), one per line:
\begin{verbatim}
0.725168 56
0.006549 126
0.040017 1
4.727988 1
0.047972 1
\end{verbatim}
Each line can be read like \emph{“\emph{x} seconds after the previous output, \emph{n} more bytes were sent to the terminal”}.
If there was no previous output (because it is the first line of timing information), the delay specifies the time between \cmd{script} invocation and the first chunk of output.

\subsection{Disadvantages}
The two file formats produced by \cmd{script}, typescript and timing, show several shortcomings with regard to forensic usage:
\begin{itemize}
\item Input coming from the user’s keyboard is not logged at all. A common example is the user entering a command in the shell but then pressing \ctrl{C} instead of return. The shell will move to the next line and display the prompt again; there is no visible distinction whether the command was run or not.\footnote{With more recent versions of Linux and Bash, terminals which have the ECHOCTL bit set (for example via stty) will show \ctrl{C} at the end of an interrupted line, which fixes this problem to some degree. Similar issues, like finding out whether the user entered or tab-completed some text, still persist.}
\item Metadata about the environment \cmd{script} runs in is not logged. This leads to a high level of uncertainty when interpreting the resulting typescript, because even important information like the character set and encoding or the terminal size and type is missing.
\item Typescript and timing are separate files, but one logical entity. They should reside in one file to protect the user from confusion and mistakes.
\item Appending to a typescript file is possible, but ambigious, since the beginning of a new part is determined only by the string \str{"Script started on~…"}. Also, appending to a typescript and recording timing information are incompatible, because \cmd{scriptreplay} will only ignore the first header line in a typescript file. Subsequent ones will disturb the timing’s byte counter.
\end{itemize}

\section{Design of \cmd{forscript}}
\subsection{File format}
A \cmd{forscript} data file (called a \emph{transcript file}) consists of the mostly unaltered output stream of the client application, but includes blocks of additional data (called \emph{control chunks}) at arbitrary positions.
A control chunk is started by a \emph{shift out} byte (\str{0x0e}) and terminated by a \emph{shift in} byte (\str{0x0f}).
Each control chunk is either an input chunk or a metadata chunk.

\subsubsection{Input chunks}
Input chunks contain the data that is sent to the client application’s input stream, which is usually identical to the user’s keyboard input.
They are of arbitrary length and terminate at the \emph{shift in} byte.
If a literal \emph{shift out} or \emph{shift in} byte needs to appear in an input chunk’s data, it is escaped by prepending a \emph{data link escape} byte (\str{0x10}).
If a literal \emph{data link escape} byte needs to appear in an input chunk’s data, it has to be doubled (i.e., \str{0x10 0x10}).
For example, if the user sends the byte sequence \str{0x4e 0x0f 0x00 0x61 0x74 0x10}, the complete input chunk that will be written to the transcript file is \str{0x0e 0x4e 0x10 0x0f 0x00 0x61 0x74 0x10 0x10 0x0f}.

\subsubsection{Metadata chunks}
Metadata chunks, also called meta chunks, contain additional information about the file or the application’s status, for example environment variables, terminal settings or time stamps.
They contain an additional \emph{shift out} byte at the beginning, followed by a byte that determines the type of metadata that follows.
The available types are described below.
Meta chunks are of arbitrary length and terminate at the \emph{shift in} byte.
The same escaping of \emph{shift out}, \emph{shift in} and \emph{data link escape} that is used for input chunks is also used for meta chunks.
For example, the “terminal size” meta type is introduced by its type byte \str{0x11}, followed by width and heigth of the terminal, represented as two unsigned big-endian 16-bit integers.
The information “terminal size is 80×16 characters” would be written to the transcript file as \str{0x0e 0x0e 0x11 0x00 0x50 0x00 0x10 0x10 0x0f}.
Note that the least significant byte of the number 16 has to be written as \str{0x10 0x10} to prevent the special meaning of \str{0x10} to escape the following \str{0x0f}.

\subsubsection{Properties of the file format}
This basic file format design has several advantages:
\begin{itemize}
\item New meta chunk types can be introduced while still allowing older tools to read the file, because the escaping rules are simple and the parsing application need not know a fixed length of each type.
\item Since switching between input and output data occurs very often in a usual terminal session, the format is designed to require very little storage overhead for these operations.
\item The format is very compact and easy to implement. Using a format like XML would decrease performance and require sophisticated libraries on the machine \cmd{forscript} is run on. However, for forensic usage it is best to be able to use a small statically linked executable.
\item Converting a \cmd{forscript} file to a \cmd{script} file is basically as easy as removing everything between \emph{shift out} and \emph{shift in} bytes (while respecting escaping rules, of course).
\end{itemize}

\subsection{Metadata chunk types}
The next sections will describe the available metadata chunk types.
Integers are unsigned and big endian, except where noted otherwise.
Numbers are represented in binary form, not as ASCII digits.

For better understanding, the code \cmd{forscript} uses to write each meta chunk appears after the chunk’s explanation.
The three functions [[chunkwh()]], [[chunkwf()]] and [[chunkwd()]] that are used for actually writing the data to disk will be explained in section~\ref{def:chunkwriters}.
To be able to understand the code, it is sufficient to know that [[chunkwh()]] takes one parameter (the chunk’s type) and writes the header bytes.
[[chunkwf()]] writes the footer byte and takes no parameters, while [[chunkwd()]] writes the payload data, escaping it on the fly, and requires a pointer and byte count.
There is an additional convenience function [[chunkwm()]] that takes all three parameters and will write a complete metadata chunk.

Chunk functions return a negative value if an error occured, \cmd{forscript} should terminate then.

A transcript file needs to begin with a \emph{file version} meta chunk, followed directly by the first \emph{start of session} chunk.

\subsubsection*{\str{0x01} File version (1 byte)}
The transcript file must start with a meta chunk of this type; there may be no other data before it.

Denotes the version of the \cmd{forscript} file format that is being used for this file.
In order to guarantee a length of exactly one byte, the version numbers 0, 14, 15 and 16 are not allowed, therefore no escaping takes place.
This document describes version 1 of the format, therefore currently the only valid value is \str{0x01}.

<<chunks>>=
int chunk01() {
	unsigned char ver = 0x01;
	return chunkwm(0x01, &ver, sizeof(ver));
}
@

\subsubsection*{\str{0x02} Begin of session (10 bytes)}
Denotes the start of a new \cmd{forscript} session.
The first four data bytes represent the start time as the number of seconds since the Unix Epoch.
The next four bytes contain a signed representation of the nanosecond offset to the number of seconds.
If these four bytes are set to \str{0xffffffff}, there was an error retrieving the nanoseconds.
The last two bytes specify the machine’s (signed) time zone offset to UTC in minutes.
If these two bytes are set to \str{0xffff}, the machine’s timezone is unknown.

<<chunks>>=
int chunk02() {
	struct timespec now;
	extern long timezone;
	int ret;
	unsigned char data[10];
	uint32_t secs;
	int32_t nanos = ~0;
	int16_t tzone = ~0;
	ret = clock_gettime(CLOCK_REALTIME, &now);
	if (ret < 0)
		return ret;
	secs = htonl(now.tv_sec);
	if (now.tv_nsec < 2000000000 && now.tv_nsec > -2000000000)
		nanos = htonl(now.tv_nsec);
	tzset();
	tzone = htons((uint16_t)(timezone / -60));
	memcpy(&data[0], &secs, sizeof(secs));
	memcpy(&data[4], &nanos, sizeof(nanos));
	memcpy(&data[8], &tzone, sizeof(tzone));
	return chunkwm(0x02, data, sizeof(data));
}
@

This chunk requires \emph{time.h} for \func{clock\_gettime()}, \emph{inet.h} for \func{htonl()} and \emph{string.h} for \func{memcpy()}:
<<includes>>=
#include <time.h>
#include <arpa/inet.h>
#include <string.h>
@

\subsubsection*{\str{0x11} Terminal size (two 2-byte values)}
Is written at session start and when the size of the terminal window changes.
The first data word contains the number of colums, the second one the number of rows.

Since the terminal size has to be passed to the running client application, the chunk itself does not request the values, but receives them as a parameter.

<<chunks>>=
int chunk11(struct winsize *size) {
	uint32_t be;
	be = htonl((size->ws_col << 16) | size->ws_row);
	return chunkwm(0x11, (unsigned char *)&be, sizeof(be));
}
@

This chunk requires \emph{ioctl.h} for \func{ioctl()}:
<<includes>>=
#include <sys/ioctl.h>
@

\subsubsection*{\str{0x12} Environment variables (arbitrary number of C strings)}
Is written at session start.
Contains the environment variables and their values as \str{NAME=value} pairs, each pair is terminated by a null byte (\str{0x00}).

<<chunks>>=
int chunk12() {
	extern char **environ;
	int i = 0;
	int ret;
	while (environ[i] != NULL) {
		if (i == 0) {
			ret = chunkwh(0x12);
			if (!ret)
				return -1;
		}
		ret = chunkw((unsigned char *)environ[i], strlen(environ[i]) + 1);
		if (ret < 0)
			return ret;
		i++;
	}
	if (i != 0) {
		ret = chunkwf();
		if (!ret)
			return -1;
	}
	return 0;
}
@

\subsubsection*{\str{0x13} Locale settings (seven C strings)}
Is written at session start.
Contains the string values of several locale settings, namely \str{LC\_ALL}, \str{LC\_COLLATE}, \str{LC\_CTYPE}, \str{LC\_MESSAGES}, \str{LC\_MONETARY}, \str{LC\_NUMERIC} and \str{LC\_TIME}, in that order.

<<chunks>>=
#define chunk13w(type) loc = setlocale(LC_##type, ""); \
        ret = chunkw((unsigned char *)loc, strlen(loc) + 1);
int chunk13() {
	char *loc;
	int ret;
	ret = chunkwh(0x13);
	chunk13w(ALL);
	chunk13w(COLLATE);
	chunk13w(CTYPE);
	chunk13w(MESSAGES);
	chunk13w(MONETARY);
	chunk13w(NUMERIC);
	chunk13w(TIME);
	ret = chunkwf();
	return 0;
}
@

This chunk requires \emph{locale.h}:
<<includes>>=
#include <locale.h>
@

\subsubsection*{\str{0x16} Delay (two 4-byte values)}
Contains the number of seconds and nanoseconds that have passed since the last delay chunk (or, if this is the first one, since the session started).

A replaying application should wait for the time specified in this chunk before advancing further in the transcript file.

\subsection{Magic number}
Since a \cmd{forscript} file has to start with a file version chunk followed by a begin of session chunk, there is a distinctive eight-byte signature at the beginning of each file:
\begin{verbatim}
0x0e 0x0e 0x01 0x?? 0x0f 0x0e 0x0e 0x02
\end{verbatim}
The first two bytes start a metadata chunk, the third one identifies it as a file version chunk.
The fourth byte contains the version number, which is currently \str{0x01} but may change in the future.
Byte 5 closes the version chunk, 5 to 8 start a begin of session chunk.

\subsection{Invocation}

\section{Implementation of \cmd{forscript}}
For improved readability, we define the special characters as constants:
<<constants>>=
const unsigned char SO  = 0x0e;
const unsigned char SI  = 0x0f;
const unsigned char DLE = 0x10;
@

It is by design that the three special characters have consecutive byte numbers.
This allows us to define a minimum and maximum byte value that requires special escape handling:
<<constants>>=
const unsigned char ESCMIN = 0x0e;
const unsigned char ESCMAX = 0x10;
@

\subsubsection{How a \cmd{forscript} file is written}
The function \emph{chunkw()} takes a pointer and a byte count as arguments and writes chunk data to the transcript file, applying required escapes on the fly.
To improve performance, it does not write byte-per-byte, but instead scans the input data until it finds a special character.
When it does, it writes everything up to, but not including, the special character to the file and then adds a DLE character.
The search then goes on.
If another special character is found, everything from the last special character (inclusive) to the current one (exclusive) plus a DLE is written.
Eventually the whole input data will have been scanned and the function terminates after writing everything from the last special character (inclusive) or the beginning of the data (if there were no special characters) to the end of the input data.
This is the code:
<<chunkw>>=
int chunkw(unsigned char *data, int count) {
	int escaped = 0;
	int pos = 0;
	int start = 0;
	while (pos < count) {
		if (data[pos] <= ESCMAX && data[pos] >= ESCMIN) {
			if (pos > start) {
				if (!swrite(&data[start], sizeof(char), pos - start, OUTF))
					return -1;
			}
			if (!swrite(&DLE, sizeof(DLE), 1, OUTF))
				return -2;
			start = pos;
			escaped++;
		}
		pos++;
	}
	if (!swrite(&data[start], sizeof(char), pos - start, OUTF))
		return -3;
	return escaped;
}
@
\emph{OUTF} is the already opened transcript file and a global variable:
<<globals>>=
FILE *OUTF;
@

The \emph{swrite()} function (“safe write”) that is being used here will return zero if the number of items written is not equal to the number of items that \emph{should} have been written:
<<swrite>>=
int swrite(const void *ptr, size_t size, size_t nmemb, FILE *stream) {
	return (fwrite(ptr, size, nmemb, stream) == nmemb);
}
@
To be able to use \func{fwrite()}, \emph{stdio.h} has to be included:
<<includes>>=
#include <stdio.h>
@

There are functions to write chunk headers and footers:
<<chunkwhf>>=
int chunkwh(unsigned char id) {
	int ret;
	for (int i = 0; i < 2; i++) {
		ret = swrite(&SO, sizeof(SO), 1, OUTF);
		if (!ret)
			return ret;
	}
	return swrite(&id, sizeof(unsigned char), 1, OUTF);
}

int chunkwf() {
	return swrite(&SI, sizeof(SI), 1, OUTF);
}
@

There is also a convenience function that writes a meta chunk’s header and footer as well as the actual data:
<<chunkwm>>=
int chunkwm(unsigned char id, unsigned char *data, int count) {
	int ret;
	if (!chunkwh(id))
		return -101;
	ret = chunkw(data, count);
	if (ret < 0)
		return ret;
	if (!chunkwf())
		return -102;
	return 1;
}
@

If the program has to terminate abnormally, the function \func{die()} will be called.
It will output an error message and exit the software.
<<die>>=
void die(char *message, int chunk) {
	fprintf(stderr, "%s: ", MYNAME);
	if (chunk != 0) {
		fprintf(stderr, "metadata chunk %02x failed", chunk);
		if (message != NULL)
			fprintf(stderr, ": ");
	} else {
		if (message == NULL)
			fprintf(stderr, "unknown error");
	}
	if (message != NULL)
		fprintf(stderr, message);
	fprintf(stderr, "; exiting.\n");
	exit(EXIT_FAILURE);
}
@
\func{exit()} requires \emph{stdlib.h}:
<<includes>>=
#include <stdlib.h>
@
The global variable \emph{MYNAME} contains a pointer to the name the binary was called as and is set in [[main()]].
<<globals>>=
char *MYNAME;
@

For convenience, we define the following macro that will call \func{die()} and supply it with the chunk’s type.
<<chunks>>=
#define chunk(num) if (chunk##num() < 0) die(NULL, 0x##num);
@

\subsection{Initialization}

\subsubsection{Determining the binary name}
To be able to output its own name (e.g. in error messages), \cmd{forscript} determines the name of the binary that has been called by the user.
This value is stored in [[argv[0]]].
The global variable [[MYNAME]] will be used to reference that value from every function that needs it.
<<setmyname>>=
MYNAME = argv[0];
@
If \cmd{forscript} was called using a path name (e.g. \str{/usr/bin/forscript}), everything up to the final slash needs to be cut off.
This is done by moving the pointer to the character immediately following the final slash.
<<setmyname>>=
{ char *lastslash;
	if ((lastslash = strrchr(MYNAME, '/')) != NULL)
		MYNAME = lastslash + 1;
}
@

\subsubsection{Command line arguments}
Since \cmd{forscript}’s invocation tries to mimic \cmd{script}’s as far as possible, command line argument handling is designed to closely resemble \cmd{script}’s behavior as far as possible.
Therefore, like in \cmd{script}, the command line switches \str{--version} and \str{-V} are treated seperately.
If there is exactly one command line argument and it is one of these, \cmd{forscript} will print its version and terminate.
<<getopt>>=
if ((argc == 2) &&
    (!strcmp(argv[1], "-V") || !strcmp(argv[1], "--version"))) {
	printf("%s %s\n", MYNAME, MYVERSION);
	return 0;
}
@
[[MYVERSION]] is defined as a global constant:
<<globals>>=
const char *MYVERSION = "0.1-git";
@

The other options are parsed using the normal [[getopt()]] method, which requires \str{unistd.h}:
<<includes>>=
#include <unistd.h>
@

[[getopt()]] returns the next option character each time it is called, and $-1$ if there are none left.
The option characters are handled in a [[switch]] statement.
As in \cmd{script}, flags that turn on some behavior cause a respective global [[int]] variable to be increased by one.
These flags are:
<<globals>>=
int aflg = 0, fflg = 0, qflg = 0;
@

The value of the \str{-c} parameter is stored in a global string:
<<globals>>=
char *cflg = NULL;
@

The \str{-t} flag is accepted for compatibility reasons, but has no effect in \cmd{forscript} because timing information is always written.

After the loop terminates, [[optind]] arguments have been parsed.
[[argc]] and [[argv]] are then modified accordingly to only handle non-option arguments (in \cmd{forscript} this is only the file name).

The parsing loop therefore looks like this:
<<getopt>>=
{ int c; extern char *optarg; extern int optind;
	while ((c = getopt(argc, argv, "ac:fqt")) != -1)
		switch ((char)c) {
		case 'a':
			aflg++; break;
		case 'c':
			cflg = optarg; break;
		case 'f':
			fflg++; break;
		case 'q':
			qflg++; break;
		case 't':
			break;
		case '?':
		default:
			fprintf(stderr,
			        "usage: %s [-afqt] [-c command] [file]\n",
			        MYNAME);
			exit(1);
			break;
		}
	argc -= optind;
	argv += optind;
}
@

After the options have been parsed, the output file name will be determined and stored in the global string [[OUTN]]:
<<globals>>=
char *OUTN = "transcript";
@

If there was no name supplied on the command line, the default name is \str{transcript}.
This differs from \cmd{script}’s default name \str{typescript} intentionally, because the file format is different and can, for example, not be displayed directly using \cmd{cat}.
If there are any scripts or constructs that assume the default output file name to be \str{typescript}, the chance that replacing \cmd{script} with \cmd{forscript} will break their functionality anyway is quite high.

\subsubsection{Opening the output file}
As in \cmd{script}, there is a safety warning if no file name was supplied and \str{transcript} exists and is a (hard or soft) link.
<<openoutfile>>=
if (argc > 0) {
	OUTN = argv[0];
} else {
	struct stat s;
	if (lstat(OUTN, &s) == 0 && (S_ISLNK(s.st_mode) || s.st_nlink > 1)) {
		fprintf(stderr, "Warning: `%s' is a link.\n"
		       "Use `%s [options] %s' if you really "
		       "want to use it.\n"
		       "%s not started.\n",
		       OUTN, MYNAME, OUTN, MYNAME);
		exit(1);
	}
}
@

[[lstat()]] needs \str{types.h} and \str{stat.h} as well as \str{\_XOPEN\_SOURCE}:
<<includes>>=
#include <sys/types.h>
#include <sys/stat.h>
@
<<featuretest>>=
#define _XOPEN_SOURCE 500
@

The file will now be opened, either for writing or for appending, depending on [[aflg]].
<<openoutfile>>=
if ((OUTF = fopen(OUTN, (aflg ? "a" : "w"))) == NULL) {
	perror(OUTN);
	die("the output file could not be opened", 0);
}
@

\subsection{Preparing a new pseudo terminal}
While \cmd{script} uses manual PTY allocation (by trying out device names) or BSD’s [[openpty()]] where available, \cmd{forscript} uses the PTY multiplexer (\str{/dev/ptmx}) standardized in POSIX.1-2001 to create a new PTY.
This method requires \str{fcntl.h} and a sufficiently high feature test macro value for POSIX code.
<<includes>>=
#include <fcntl.h>
@
<<featuretest>>=
#define _POSIX_C_SOURCE 200112L
@

The PTY’s master and slave file descriptors will be stored in these global variables:
<<globals>>=
int PTM = 0, PTS = 0;
@

A new PTY master is requested like this:
<<openpt>>=
if ((PTM = posix_openpt(O_RDWR | O_NOCTTY)) < 0) {
	perror("openpt");
	die("openpt failed", 0);
}
@

Then, access to the slave is granted.
<<openpt>>=
if (grantpt(PTM) < 0) {
	perror("grantpt");
	die("grantpt failed", 0);
}
if (unlockpt(PTM) < 0) {
	perror("unlockpt");
	die("unlockpt failed", 0);
}
@

The slave’s device file name is requested using [[ptsname()]].
Since the name is not needed during further execution, the slave will be opened and its file descriptor stored.
<<openpt>>=
{ char *pts = NULL;
	if ((pts = ptsname(PTM)) != NULL) {
		if ((PTS = open(pts, O_RDWR)) < 0) {
			perror(pts);
			die("pts open failed", 0);
		}
	} else {
		perror("ptsname");
		die("ptsname failed", 0);
	}
}
@

\subsubsection{Getting notified about window size changes}
If the size of a terminal window changes, the controlling process receives a \str{SIGWINCH} signal and should act accordingly.
\cmd{forscript} does this in the [[resize()]] function.
The new size is retrieved, stored in the transcript file and set to the client application.
<<resized>>=
void resized(int signal) {
	UNUSED(signal);
	struct winsize size;
	RESIZED = 1;
	ioctl(0, TIOCGWINSZ, &size);
	if (chunk11(&size) < 0)
		die("handling SIGWINCH", 0x11);
	ioctl(PTS, TIOCSWINSZ, &size);
}
@

Since the I/O handling code uses [[select()]] to wait for data, it will be interrupted when the \str{SIGWINCH} signal is received.
The global variable [[RESIZED]] exists to inform the I/O handler that it has been interrupted by \str{SIGWINCH}.
The I/O code will reset its value and continue operation.
<<globals>>=
int RESIZED = 0;
@

To initialize the client PTY’s window size, the reception of \str{SIGWINCH} will be simulated now.
Since the client is not yet running, [[RESIZED]] will be reset afterwards.
<<openpt>>=
resized(0);
RESIZED = 0;
@

\subsection{Launching subprocesses}
The original \cmd{script} uses one process to listen for input, one to listen for output and one to initialize and [[execl()]] the command to be recorded.
\cmd{forscript} in contrast uses only the [[select()]] function to be notified of pending input and output and therefore only needs two processes: Itself and the subcommand.

\subsubsection{Registering signal handlers}
To be notified of an exiting subprocess, a handler for the \str{SIGCHLD} signal needs to be defined.
This signal is sent by the operating system if any child process’s run status changes, i.e. it is stopped (\str{SIGSTOP}), continued (\str{SIGCONT}) or it exits.
\cmd{script} terminates if the child is stopped, but \cmd{forscript} does not.
The function [[finish()]] handles the child’s termination and is defined in section \ref{def:finish}.
<<sigchld>>=
{ struct sigaction sa;
	sigemptyset(&sa.sa_mask);
	sa.sa_flags = SA_NOCLDSTOP;
	sa.sa_handler = finish;
	sigaction(SIGCHLD, &sa, NULL);
}
@
These functions and constants require \str{signal.h}.
<<includes>>=
#include <signal.h>
@

\subsubsection{Forking}
When a progam calls the [[fork()]] function, the operating system basically clones the program into a new process that is a subprocess of the caller.
Both processes continue to run at the next command after the [[fork()]] call, but the value [[fork()]] returned will be different:
The child will see a return value of [[0]], while the parent will retrieve the process ID of the child.
A negative value will be returned if the fork did not succeed.
<<fork>>=
if ((CHILD = fork()) < 0) {
	perror("fork");
	die("fork failed", 0);
}
@
[[CHILD]] is used in several places when dealing with the subprocess, therefore it is a global variable.
<<globals>>=
int CHILD = 0;
@

After forking, the child launches (or, to be exact, becomes) the process that should be logged, while the parent does the actual input/output logging.
<<fork>>=
if (CHILD == 0)
	doshell();
else
	doio();
@

\subsection{Running the target application}
The [[doshell()]] function is run in the child process, whose only task it is to set up all required PTY redirections and then execute the client command.
Therefore, open file descriptors from the parent process which are no longer needed are closed early.
<<doshell>>=
void doshell() {
	close(PTM);
	fclose(OUTF);
@
Standard input, output and error are bound to the PTY slave.
<<doshell>>=
	dup2(PTS, 0);
	dup2(PTS, 1);
	dup2(PTS, 2);
@
If the environment variable \str{\$SHELL} is set, its value is used.
Otherwise the default is \str{/bin/sh}, which should exist on all Unix systems.
<<doshell>>=
	char *shell;
	if ((shell = getenv("SHELL")) == NULL)
		shell = "/bin/sh";
@
Next, the name of the shell, without any path components, is determined to be used as argument zero when executing the client command.
<<doshell>>=
	char *shname;
	if ((shname = strrchr(shell, '/')) == NULL)
		shname = shell;
	else
		shname++;
@
Finally, the [[execl()]] function is used to replace the currently running \cmd{forscript} process with the shell that has just been selected.
If a target command has been specified using the \str{-c} option, it will be passed to the shell.
Else, an interactive shell is launched using the \str{-i} option.
<<doshell>>=
	if (cflg != NULL)
		execl(shell, shname, "-c", cflg, NULL);
	else
		execl(shell, shname, "-i", NULL);
@
The \cmd{forscript} child process should now have been replaced with the shell.
If execution reaches code after [[execl()]], an error occured and the child process will terminate with an error message.
<<doshell>>=
	perror(shell);
	die("execing the shell failed", 0);
}
@

\subsection{Handling input and output}
<<doio>>=
void doio() {
}
@

\subsection{Finishing execution}
Since a signal handler can handle more than one signal, its number is passed as an argument.
However, [[finish()]] only handles \str{SIGCHLD}, therefore it will ignore its argument.
<<finish>>=
void finish(int signal) {
	UNUSED(signal);
}
@

[[UNUSED]] is a macro that causes your compiler to stop warning you about an unused parameter:
<<macros>>=
#define UNUSED(var) while (0) { (void)(var); }
@



<<forscript.c>>=
<<featuretest>>
<<macros>>
<<includes>>

<<constants>>

<<globals>>
extern FILE *stdout;

<<die>>

<<swrite>>

<<chunkw>>

<<chunkwhf>>

<<chunkwm>>

<<chunks>>

<<finish>>

<<resized>>

<<doshell>>

<<doio>>

int main(int argc, char *argv[])
{
	<<setmyname>>
	<<getopt>>
	<<openoutfile>>
	<<openpt>>
	<<sigchld>>
	<<fork>>
	return EXIT_SUCCESS;
}
@

\section{Evaluation}

\section{Summary}

% This is where it all ends.
\end{document}
