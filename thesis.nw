% This uses my article.tex include.
\input{article.tex}
% We use noweb.
\usepackage{noweb}
\def\cmd{\emph}
\def\func{\emph}
\def\param{\texttt}
\def\str{\texttt}
\def\bs{\textbackslash}
\def\key{\texttt}
\newcommand\ctrl[1]{\key{\char`\^#1}}
% The fun begins.
\begin{document}

\section{The \cmd{script} implementation in \emph{util-linux-ng}}
\emph{util-linux} is the name of a collection of command-line utilities for Linux systems.
It includes essential software like \cmd{dmesg}, \cmd{fdisk}, \cmd{mkswap}, \cmd{mount} and \cmd{shutdown} as well as the \cmd{script} and \cmd{scriptreplay} utilities.

The original \emph{util-linux} package was abandoned in 2006.
Today, it has been replaced by its successor \emph{util-linux-ng}, a fork of the last available \emph{util-linux} version.
\emph {util-linux-ng} is under active development.
The analysis of the original \cmd{script} utility in this thesis is based on the most recent \emph{util-linux} release as of the time of writing, version 2.17.

\subsection{Behavior of the \emph{script} utility}
\cmd{script} takes one optional argument, the file name of the typescript file to generate.
If the argument is omitted, the file will be named \emph{typescript}.
There are also several command-line switches that modify \cmd{script}’s behavior.

The \param{-a} switch will pass the \emph{a} flag to \func{fopen()}’s \emph{mode} parameter instead of \emph{w}.
If a typescript file does already exist, it will then not be overwritten; instead, the new content will be appended to the existing file.

If the \param{-f} switch is used, \cmd{script} will call \func{fflush()} on the typescript file after new data has been written to it.
This results in instant updates to the typescript file, at the expense of performance.

%FIXME: Continue.

\section{A new typescript file format}
The current implementation of \cmd{script} uses a very simple typescript file format:
Everything the client application sends to the terminal (i.e. everything printed on screen) will be written to the file, byte for byte, including control characters that are used for various tasks like setting colors, positioning the cursor etc.
Additionally, a header \str{"Script started on XXX\bs{}n"} is written, where \str{XXX} is the human-readable date and time when \cmd{script} was invoked.
If \cmd{script} was invoked without the \param{-q} flag, an additional footer \str{"Script done on YYY\bs{}n"}, where \str{YYY} is the human-readable date and time when \cmd{script} terminated, is written.

Since this typescript format completely lacks timing information, the \param{-t} flag will output timing data to stderr.
The user has to capture this output to a file by calling \cmd{script} like this: \str{script -t 2>timingfile}.

The timing file consists of tuples of delay and byte count (space-separated), one per line:
\begin{verbatim}
0.725168 56
0.006549 126
0.040017 1
4.727988 1
0.047972 1
\end{verbatim}
Each line can be read like \emph{“\emph{x} seconds after the previous output, \emph{n} more bytes were sent to the terminal”}.
If there was no previous output (because it is the first line of timing information), the delay specifies the time between \cmd{script} invocation and the first chunk of output.

The two file formats produced by \cmd{script}, typescript and timing, show several shortcomings with regard to forensic usage:
\begin{itemize}
\item Input coming from the user’s keyboard is not logged at all. A common example is the user entering a command in the shell but then pressing \ctrl{C} instead of return. The shell will move to the next line and display the prompt again; there is no visible distinction whether the command was run or not.\footnote{With more recent versions of Linux and Bash, terminals which have the ECHOCTL bit set (for example via stty) will show \ctrl{C} at the end of an interrupted line, which fixes this problem to some degree. Similar issues, like finding out whether the user entered or tab-completed some text, still persist.}
\item Metadata about the environment \cmd{script} runs in is not logged. This leads to a high level of uncertainty when interpreting the resulting typescript, because even important information like the character set and encoding or the terminal size and type is missing.
\item Typescript and timing are separate files, but one logical entity. They should reside in one file to protect the user from confusion and mistakes.
\item Appending to a typescript file is possible, but ambigious, since the beginning of a new part is determined only by the string \str{"Script started on~…"}. Also, appending to a typescript and recording timing information are incompatible, because \cmd{scriptreplay} will only ignore the first header line in a typescript file. Subsequent ones will disturb the timing’s byte counter.
\end{itemize}

\subsection{The new file format}
A \cmd{forscript} data file consists of the unaltered output stream of the client application, but includes blocks of metadata (called \emph{metadata blocks}) at arbitrary positions.
A metadata block is started by the byte sequence \str{0x00 0x0e} (\emph{null, shift out}), terminated by the byte sequence \str{0x00 0x0f} (\emph{null, shift in}) and may contain several pieces of information (called \emph{data chunks}) which are described below.
Empty metadata blocks (\str{0x00 0x0e 0x00 0x0f}) are permitted, but not useful.
If a literal null byte (\str{0x00}) needs to appear inside or outside a metadata block, it has to be written as two null bytes instead (\str{0x00 0x00}).

Data chunks may, depending on their type, be of fixed or variable length.
They are introduced by a single byte denoting their type and may contain arbitrary byte values, although the range of allowed or useful values can be further limited depending on their type.
All data chunks (variable \emph{and} fixed length) are terminated by the byte sequence \str{0x00 0x17} (\emph{null, end of transmission block}).
This allows the introduction of new data chunk types while still allowing older versions of \cmd{forscript} to read the basic file structure.
If a literal null byte (\str{0x00}) needs to appear inside a data chunk, it has to be written as two null bytes instead (\str{0x00 0x00}).

A \cmd{forscript} data file needs to begin with a non-empty metadata block containing a \emph{file version} data chunk.

The next sections will describe the available data chunk types.

\subsubsection*{\str{0x01} File version}
Fixed length of 1 byte.
Needs to appear only once per file and before any other data chunks.
Must be the only chunk in its metadata block.

Denotes the version of the \cmd{forscript} file format that is being used for this file.
Versions are represented as byte values, not ASCII numbers.
The version number \str{0x00} is not allowed.
This document describes version 1 of the format, therefore currently the only valid value is \str{0x01}.

\subsection{Magic number}
Since a \cmd{forscript} file has to start with a file version chunk, there is a distinctive eight-byte signature at the beginning of each file:
\begin{verbatim}
0x00 0x0e 0x01 0x?? 0x00 0x17 0x00 0x0f
\end{verbatim}
The first two bytes start a metadata block, the third one the version chunk.
The fourth byte contains the version number and may be any value (except \str{0x00}) in the future, but is currently always \str{0x01}.
Bytes 5 and 6 close the version chunk, bytes 7 and 8 close the metadata block.

% This is where it all ends.
\end{document}

<<forscript.c>>=
# include <stdio.h>
# include <stdlib.h>

int main(void)
{
    printf("Hello World!\n");
    return EXIT_SUCCESS;
}
@
